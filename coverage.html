
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>engine: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/AutoCookies/pomai-cache/internal/engine/adaptive_ttl.go (0.0%)</option>
				
				<option value="file1">github.com/AutoCookies/pomai-cache/internal/engine/memory_controller.go (0.0%)</option>
				
				<option value="file2">github.com/AutoCookies/pomai-cache/internal/engine/replication.go (0.0%)</option>
				
				<option value="file3">github.com/AutoCookies/pomai-cache/internal/engine/store.go (46.5%)</option>
				
				<option value="file4">github.com/AutoCookies/pomai-cache/internal/engine/store_eviction.go (75.0%)</option>
				
				<option value="file5">github.com/AutoCookies/pomai-cache/internal/engine/store_singleflight.go (64.7%)</option>
				
				<option value="file6">github.com/AutoCookies/pomai-cache/internal/engine/store_snapshot.go (75.8%)</option>
				
				<option value="file7">github.com/AutoCookies/pomai-cache/internal/engine/store_stats.go (47.1%)</option>
				
				<option value="file8">github.com/AutoCookies/pomai-cache/internal/engine/store_ttl.go (29.1%)</option>
				
				<option value="file9">github.com/AutoCookies/pomai-cache/internal/engine/store_zset.go (78.9%)</option>
				
				<option value="file10">github.com/AutoCookies/pomai-cache/internal/engine/tenants.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// File: internal/cache/adaptive_ttl.go
package engine

import (
        "math"
        "time"
)

type AdaptiveTTL struct {
        minTTL          time.Duration
        maxTTL          time.Duration
        baseAccessCount uint64
        decayFactor     float64
}

func NewAdaptiveTTL(minTTL, maxTTL time.Duration) *AdaptiveTTL <span class="cov0" title="0">{
        return &amp;AdaptiveTTL{
                minTTL:      minTTL,
                maxTTL:      maxTTL,
                decayFactor: 0.9, // Hot items get longer TTL
        }
}</span>

// ComputeTTL calculates adaptive TTL based on access patterns
func (a *AdaptiveTTL) ComputeTTL(accesses uint64, age time.Duration) time.Duration <span class="cov0" title="0">{
        if accesses == 0 </span><span class="cov0" title="0">{
                return a.minTTL
        }</span>

        // Hotness score:  more accesses + recency = longer TTL
        <span class="cov0" title="0">hotnessScore := float64(accesses) * math.Exp(-age.Seconds()/3600) // Decay over 1 hour

        // Scale TTL between min and max
        ratio := math.Min(1.0, hotnessScore/100.0) // Cap at 100 accesses
        ttl := time.Duration(float64(a.minTTL) + ratio*float64(a.maxTTL-a.minTTL))

        return ttl</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package engine

import (
        "sync/atomic"
        "time"
)

// MemoryController manages a global memory budget across all tenant stores.
type MemoryController struct {
        capacity int64 // 0 = unlimited
        used     int64
        tm       *TenantManager
}

// NewMemoryController creates controller. capacityBytes = 0 =&gt; unlimited.
func NewMemoryController(tm *TenantManager, capacityBytes int64) *MemoryController <span class="cov0" title="0">{
        return &amp;MemoryController{
                capacity: capacityBytes,
                used:     0,
                tm:       tm,
        }
}</span>

// Used returns current used bytes
func (mc *MemoryController) Used() int64 <span class="cov0" title="0">{
        return atomic.LoadInt64(&amp;mc.used)
}</span>

// Capacity returns capacity
func (mc *MemoryController) Capacity() int64 <span class="cov0" title="0">{
        return mc.capacity
}</span>

// Reserve tries to reserve n bytes. Returns true if reserved.
// If capacity == 0 (unlimited) always succeeds.
// On transient shortage, it will attempt force-eviction across stores once, then fail.
func (mc *MemoryController) Reserve(n int64) bool <span class="cov0" title="0">{
        if n &lt;= 0 </span><span class="cov0" title="0">{
                return true
        }</span>
        // unlimited
        <span class="cov0" title="0">if mc.capacity == 0 </span><span class="cov0" title="0">{
                atomic.AddInt64(&amp;mc.used, n)
                return true
        }</span>

        // Fast path: try to add
        <span class="cov0" title="0">new := atomic.AddInt64(&amp;mc.used, n)
        if new &lt;= mc.capacity </span><span class="cov0" title="0">{
                return true
        }</span>

        // Exceeded -&gt; roll back and try eviction
        <span class="cov0" title="0">atomic.AddInt64(&amp;mc.used, -n)

        // Trigger eviction across tenants to free up at most n bytes (best-effort).
        // Use short time window to avoid long GC or stalls.
        mc.forceEvictAcrossStores(n)

        // Retry once
        new = atomic.AddInt64(&amp;mc.used, n)
        if new &lt;= mc.capacity </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">atomic.AddInt64(&amp;mc.used, -n)
        return false</span>
}

// Release releases previously reserved bytes.
func (mc *MemoryController) Release(n int64) <span class="cov0" title="0">{
        if n &lt;= 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if mc.capacity == 0 </span><span class="cov0" title="0">{
                // no accounting needed for unlimited
                atomic.AddInt64(&amp;mc.used, -n)
                return
        }</span>
        <span class="cov0" title="0">atomic.AddInt64(&amp;mc.used, -n)
        if atomic.LoadInt64(&amp;mc.used) &lt; 0 </span><span class="cov0" title="0">{
                atomic.StoreInt64(&amp;mc.used, 0)
        }</span>
}

// forceEvictAcrossStores tries to free target bytes by asking each tenant store to force-evict.
// This is best-effort and returns immediately after a short sweep.
func (mc *MemoryController) forceEvictAcrossStores(target int64) <span class="cov0" title="0">{
        if target &lt;= 0 || mc.tm == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // iterate tenants and ask them to evict some bytes.
        // We cap per-store eviction attempt to avoid starving a single tenant.
        <span class="cov0" title="0">perStoreTarget := target / int64(len(mc.tm.stores)+1)
        if perStoreTarget &lt;= 0 </span><span class="cov0" title="0">{
                perStoreTarget = target // try full target on first store
        }</span>

        // Simple round-robin sweep with short sleeps to allow locks to settle.
        <span class="cov0" title="0">for _, id := range mc.tm.ListTenants() </span><span class="cov0" title="0">{
                s := mc.tm.GetStore(id)
                if s == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                // best-effort: ask store to evict perStoreTarget
                <span class="cov0" title="0">freed := s.ForceEvictBytes(perStoreTarget)
                if freed &gt;= target </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">target -= freed
                // small pause to avoid tight loop
                time.Sleep(5 * time.Millisecond)
                if target &lt;= 0 </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // If still need more, do another light pass with smaller per-store target
        <span class="cov0" title="0">for _, id := range mc.tm.ListTenants() </span><span class="cov0" title="0">{
                s := mc.tm.GetStore(id)
                if s == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">freed := s.ForceEvictBytes(int64(1024 * 32)) // try 32 KB chunks
                if freed &lt;= 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if freed &gt;= target </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">target -= freed</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package engine

import (
        "context"
        "encoding/gob"
        "errors"
        "fmt"
        "io"
        "log"
        "net"
        "sync"
        "sync/atomic"
        "time"
)

var (
        ErrNotLeader        = errors.New("not leader")
        ErrNoHealthyPeers   = errors.New("no healthy peers available")
        ErrReplicationLag   = errors.New("replication lag exceeded threshold")
        ErrPeerDisconnected = errors.New("peer disconnected")
)

type ReplicationMode int

const (
        ModeAsync ReplicationMode = iota
        ModeSync
        ModeSemiSync
)

type OpType uint8

const (
        OpTypeSet OpType = iota + 1
        OpTypeDelete
        OpTypeIncr
)

type ReplicaOp struct {
        Type      OpType
        Key       string
        Value     []byte
        Delta     int64
        TTL       time.Duration
        Timestamp int64
        SeqNum    uint64
        TenantID  string
}

type PeerStatus int

const (
        PeerHealthy PeerStatus = iota
        PeerDegraded
        PeerDown
)

type Peer struct {
        ID          string
        Addr        string
        conn        net.Conn
        encoder     *gob.Encoder
        decoder     *gob.Decoder
        mu          sync.RWMutex
        status      PeerStatus
        lastSeqAck  uint64
        lastContact time.Time
        lag         int64
}

type ReplicationManager struct {
        nodeID       string
        mode         ReplicationMode
        tenants      *TenantManager
        peers        map[string]*Peer
        peersMu      sync.RWMutex
        isLeader     atomic.Bool
        seqNum       uint64
        opLog        *OpLog
        ctx          context.Context
        cancel       context.CancelFunc
        writeQuorum  int
        maxLagMillis int64
        stats        ReplicationStats
}

type ReplicationStats struct {
        TotalOps         uint64
        ReplicatedOps    uint64
        FailedReplicas   uint64
        AverageLatencyMs int64
        CurrentLag       int64
}

type OpLog struct {
        mu      sync.RWMutex
        entries []ReplicaOp
        maxSize int
        head    uint64
}

func NewOpLog(maxSize int) *OpLog <span class="cov0" title="0">{
        if maxSize &lt;= 0 </span><span class="cov0" title="0">{
                maxSize = 100000
        }</span>
        <span class="cov0" title="0">return &amp;OpLog{
                entries: make([]ReplicaOp, 0, maxSize),
                maxSize: maxSize,
                head:    0,
        }</span>
}

func (ol *OpLog) Append(op ReplicaOp) uint64 <span class="cov0" title="0">{
        ol.mu.Lock()
        defer ol.mu.Unlock()

        ol.head++
        op.SeqNum = ol.head

        if len(ol.entries) &gt;= ol.maxSize </span><span class="cov0" title="0">{
                ol.entries = ol.entries[1:]
        }</span>

        <span class="cov0" title="0">ol.entries = append(ol.entries, op)
        return ol.head</span>
}

func (ol *OpLog) GetSince(seqNum uint64) []ReplicaOp <span class="cov0" title="0">{
        ol.mu.RLock()
        defer ol.mu.RUnlock()

        result := make([]ReplicaOp, 0)
        for _, op := range ol.entries </span><span class="cov0" title="0">{
                if op.SeqNum &gt; seqNum </span><span class="cov0" title="0">{
                        result = append(result, op)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

func NewReplicationManager(nodeID string, mode ReplicationMode, tenants *TenantManager) *ReplicationManager <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())

        rm := &amp;ReplicationManager{
                nodeID:       nodeID,
                mode:         mode,
                tenants:      tenants,
                peers:        make(map[string]*Peer),
                opLog:        NewOpLog(100000),
                ctx:          ctx,
                cancel:       cancel,
                writeQuorum:  1,
                maxLagMillis: 5000,
        }

        rm.isLeader.Store(true)

        go rm.healthCheckLoop()
        go rm.metricsLoop()

        return rm
}</span>

func (rm *ReplicationManager) AddPeer(peerID, addr string) error <span class="cov0" title="0">{
        conn, err := net.DialTimeout("tcp", addr, 5*time.Second)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to peer %s: %w", peerID, err)
        }</span>

        <span class="cov0" title="0">peer := &amp;Peer{
                ID:          peerID,
                Addr:        addr,
                conn:        conn,
                encoder:     gob.NewEncoder(conn),
                decoder:     gob.NewDecoder(conn),
                status:      PeerHealthy,
                lastContact: time.Now(),
                lastSeqAck:  0,
        }

        rm.peersMu.Lock()
        rm.peers[peerID] = peer
        rm.peersMu.Unlock()

        go rm.handlePeer(peer)

        log.Printf("[REPLICATION] Peer added: %s (%s)", peerID, addr)
        return nil</span>
}

func (rm *ReplicationManager) RemovePeer(peerID string) <span class="cov0" title="0">{
        rm.peersMu.Lock()
        peer, ok := rm.peers[peerID]
        if ok </span><span class="cov0" title="0">{
                peer.conn.Close()
                delete(rm.peers, peerID)
        }</span>
        <span class="cov0" title="0">rm.peersMu.Unlock()

        log.Printf("[REPLICATION] Peer removed: %s", peerID)</span>
}

func (rm *ReplicationManager) Replicate(op ReplicaOp) error <span class="cov0" title="0">{
        if !rm.isLeader.Load() </span><span class="cov0" title="0">{
                return ErrNotLeader
        }</span>

        <span class="cov0" title="0">op.Timestamp = time.Now().UnixNano()
        seqNum := rm.opLog.Append(op)
        op.SeqNum = seqNum

        atomic.AddUint64(&amp;rm.stats.TotalOps, 1)

        switch rm.mode </span>{
        case ModeAsync:<span class="cov0" title="0">
                go rm.replicateAsync(op)
                return nil</span>

        case ModeSync:<span class="cov0" title="0">
                return rm.replicateSync(op)</span>

        case ModeSemiSync:<span class="cov0" title="0">
                return rm.replicateSemiSync(op)</span>

        default:<span class="cov0" title="0">
                return errors.New("unknown replication mode")</span>
        }
}

func (rm *ReplicationManager) replicateAsync(op ReplicaOp) <span class="cov0" title="0">{
        rm.peersMu.RLock()
        peers := make([]*Peer, 0, len(rm.peers))
        for _, peer := range rm.peers </span><span class="cov0" title="0">{
                if peer.status == PeerHealthy </span><span class="cov0" title="0">{
                        peers = append(peers, peer)
                }</span>
        }
        <span class="cov0" title="0">rm.peersMu.RUnlock()

        for _, peer := range peers </span><span class="cov0" title="0">{
                go rm.sendOpToPeer(peer, op)
        }</span>
}

func (rm *ReplicationManager) replicateSync(op ReplicaOp) error <span class="cov0" title="0">{
        rm.peersMu.RLock()
        peers := make([]*Peer, 0, len(rm.peers))
        for _, peer := range rm.peers </span><span class="cov0" title="0">{
                if peer.status == PeerHealthy </span><span class="cov0" title="0">{
                        peers = append(peers, peer)
                }</span>
        }
        <span class="cov0" title="0">rm.peersMu.RUnlock()

        if len(peers) == 0 </span><span class="cov0" title="0">{
                return ErrNoHealthyPeers
        }</span>

        <span class="cov0" title="0">errCh := make(chan error, len(peers))
        for _, peer := range peers </span><span class="cov0" title="0">{
                go func(p *Peer) </span><span class="cov0" title="0">{
                        errCh &lt;- rm.sendOpToPeer(p, op)
                }</span>(peer)
        }

        <span class="cov0" title="0">successCount := 0
        for i := 0; i &lt; len(peers); i++ </span><span class="cov0" title="0">{
                if err := &lt;-errCh; err == nil </span><span class="cov0" title="0">{
                        successCount++
                }</span>
        }

        <span class="cov0" title="0">if successCount == len(peers) </span><span class="cov0" title="0">{
                atomic.AddUint64(&amp;rm.stats.ReplicatedOps, 1)
                return nil
        }</span>

        <span class="cov0" title="0">atomic.AddUint64(&amp;rm.stats.FailedReplicas, 1)
        return fmt.Errorf("sync replication failed: %d/%d peers succeeded", successCount, len(peers))</span>
}

func (rm *ReplicationManager) replicateSemiSync(op ReplicaOp) error <span class="cov0" title="0">{
        rm.peersMu.RLock()
        peers := make([]*Peer, 0, len(rm.peers))
        for _, peer := range rm.peers </span><span class="cov0" title="0">{
                if peer.status == PeerHealthy </span><span class="cov0" title="0">{
                        peers = append(peers, peer)
                }</span>
        }
        <span class="cov0" title="0">rm.peersMu.RUnlock()

        if len(peers) == 0 </span><span class="cov0" title="0">{
                return ErrNoHealthyPeers
        }</span>

        <span class="cov0" title="0">quorum := (len(peers) / 2) + 1
        if rm.writeQuorum &gt; 0 </span><span class="cov0" title="0">{
                quorum = rm.writeQuorum
        }</span>

        <span class="cov0" title="0">errCh := make(chan error, len(peers))
        for _, peer := range peers </span><span class="cov0" title="0">{
                go func(p *Peer) </span><span class="cov0" title="0">{
                        errCh &lt;- rm.sendOpToPeer(p, op)
                }</span>(peer)
        }

        <span class="cov0" title="0">successCount := 0
        timeout := time.After(100 * time.Millisecond)

        for i := 0; i &lt; len(peers); i++ </span><span class="cov0" title="0">{
                select </span>{
                case err := &lt;-errCh:<span class="cov0" title="0">
                        if err == nil </span><span class="cov0" title="0">{
                                successCount++
                                if successCount &gt;= quorum </span><span class="cov0" title="0">{
                                        atomic.AddUint64(&amp;rm.stats.ReplicatedOps, 1)
                                        go func() </span><span class="cov0" title="0">{
                                                for j := i + 1; j &lt; len(peers); j++ </span><span class="cov0" title="0">{
                                                        &lt;-errCh
                                                }</span>
                                        }()
                                        <span class="cov0" title="0">return nil</span>
                                }
                        }
                case &lt;-timeout:<span class="cov0" title="0">
                        if successCount &gt;= quorum </span><span class="cov0" title="0">{
                                atomic.AddUint64(&amp;rm.stats.ReplicatedOps, 1)
                                return nil
                        }</span>
                        <span class="cov0" title="0">atomic.AddUint64(&amp;rm.stats.FailedReplicas, 1)
                        return fmt.Errorf("semi-sync timeout:  %d/%d quorum not met", successCount, quorum)</span>
                }
        }

        <span class="cov0" title="0">if successCount &gt;= quorum </span><span class="cov0" title="0">{
                atomic.AddUint64(&amp;rm.stats.ReplicatedOps, 1)
                return nil
        }</span>

        <span class="cov0" title="0">atomic.AddUint64(&amp;rm.stats.FailedReplicas, 1)
        return fmt.Errorf("semi-sync failed: %d/%d quorum not met", successCount, quorum)</span>
}

func (rm *ReplicationManager) sendOpToPeer(peer *Peer, op ReplicaOp) error <span class="cov0" title="0">{
        peer.mu.Lock()
        defer peer.mu.Unlock()

        if peer.status == PeerDown </span><span class="cov0" title="0">{
                return ErrPeerDisconnected
        }</span>

        <span class="cov0" title="0">start := time.Now()

        if err := peer.encoder.Encode(op); err != nil </span><span class="cov0" title="0">{
                peer.status = PeerDegraded
                return fmt.Errorf("encode error: %w", err)
        }</span>

        <span class="cov0" title="0">var ack struct {
                SeqNum uint64
                Status string
        }

        peer.conn.SetReadDeadline(time.Now().Add(50 * time.Millisecond))
        if err := peer.decoder.Decode(&amp;ack); err != nil </span><span class="cov0" title="0">{
                if netErr, ok := err.(net.Error); ok &amp;&amp; netErr.Timeout() </span><span class="cov0" title="0">{
                        peer.status = PeerDegraded
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("decode ack error: %w", err)</span>
        }

        <span class="cov0" title="0">peer.lastSeqAck = ack.SeqNum
        peer.lastContact = time.Now()
        peer.lag = time.Since(start).Milliseconds()

        if peer.status != PeerHealthy </span><span class="cov0" title="0">{
                peer.status = PeerHealthy
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (rm *ReplicationManager) handlePeer(peer *Peer) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                peer.conn.Close()
                rm.RemovePeer(peer.ID)
        }</span>()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-rm.ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">var op ReplicaOp
                peer.conn.SetReadDeadline(time.Now().Add(30 * time.Second))

                if err := peer.decoder.Decode(&amp;op); err != nil </span><span class="cov0" title="0">{
                        if err == io.EOF </span><span class="cov0" title="0">{
                                log.Printf("[REPLICATION] Peer %s disconnected", peer.ID)
                                return
                        }</span>
                        <span class="cov0" title="0">if netErr, ok := err.(net.Error); ok &amp;&amp; netErr.Timeout() </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">log.Printf("[REPLICATION] Decode error from peer %s: %v", peer.ID, err)
                        return</span>
                }

                <span class="cov0" title="0">if err := rm.applyOp(op); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[REPLICATION] Failed to apply op from peer %s: %v", peer.ID, err)
                }</span>

                <span class="cov0" title="0">ack := struct {
                        SeqNum uint64
                        Status string
                }{
                        SeqNum: op.SeqNum,
                        Status: "ok",
                }

                if err := peer.encoder.Encode(ack); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[REPLICATION] Failed to send ack to peer %s: %v", peer.ID, err)
                        return
                }</span>
        }
}

func (rm *ReplicationManager) applyOp(op ReplicaOp) error <span class="cov0" title="0">{
        store := rm.tenants.GetStore(op.TenantID)

        switch op.Type </span>{
        case OpTypeSet:<span class="cov0" title="0">
                return store.Put(op.Key, op.Value, op.TTL)</span>

        case OpTypeDelete:<span class="cov0" title="0">
                store.Delete(op.Key)
                return nil</span>

        case OpTypeIncr:<span class="cov0" title="0">
                _, err := store.Incr(op.Key, op.Delta)
                return err</span>

        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown op type: %d", op.Type)</span>
        }
}

func (rm *ReplicationManager) healthCheckLoop() <span class="cov0" title="0">{
        ticker := time.NewTicker(5 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-rm.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        rm.checkPeerHealth()</span>
                }
        }
}

func (rm *ReplicationManager) checkPeerHealth() <span class="cov0" title="0">{
        now := time.Now()

        rm.peersMu.Lock()
        defer rm.peersMu.Unlock()

        for _, peer := range rm.peers </span><span class="cov0" title="0">{
                peer.mu.RLock()
                timeSinceContact := now.Sub(peer.lastContact)
                lag := peer.lag
                peer.mu.RUnlock()

                if timeSinceContact &gt; 30*time.Second </span><span class="cov0" title="0">{
                        peer.mu.Lock()
                        peer.status = PeerDown
                        peer.mu.Unlock()
                        log.Printf("[REPLICATION] Peer %s marked as DOWN (no contact for %v)", peer.ID, timeSinceContact)
                }</span> else<span class="cov0" title="0"> if lag &gt; rm.maxLagMillis </span><span class="cov0" title="0">{
                        peer.mu.Lock()
                        peer.status = PeerDegraded
                        peer.mu.Unlock()
                        log.Printf("[REPLICATION] Peer %s marked as DEGRADED (lag:  %dms)", peer.ID, lag)
                }</span>
        }
}

func (rm *ReplicationManager) metricsLoop() <span class="cov0" title="0">{
        ticker := time.NewTicker(10 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-rm.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        rm.logMetrics()</span>
                }
        }
}

func (rm *ReplicationManager) logMetrics() <span class="cov0" title="0">{
        stats := rm.GetStats()
        log.Printf("[REPLICATION] Stats: TotalOps=%d, Replicated=%d, Failed=%d, AvgLatency=%dms",
                stats.TotalOps, stats.ReplicatedOps, stats.FailedReplicas, stats.AverageLatencyMs)
}</span>

func (rm *ReplicationManager) GetStats() ReplicationStats <span class="cov0" title="0">{
        return ReplicationStats{
                TotalOps:         atomic.LoadUint64(&amp;rm.stats.TotalOps),
                ReplicatedOps:    atomic.LoadUint64(&amp;rm.stats.ReplicatedOps),
                FailedReplicas:   atomic.LoadUint64(&amp;rm.stats.FailedReplicas),
                AverageLatencyMs: atomic.LoadInt64(&amp;rm.stats.AverageLatencyMs),
                CurrentLag:       atomic.LoadInt64(&amp;rm.stats.CurrentLag),
        }
}</span>

func (rm *ReplicationManager) SetMode(mode ReplicationMode) <span class="cov0" title="0">{
        rm.mode = mode
        log.Printf("[REPLICATION] Mode changed to:  %d", mode)
}</span>

func (rm *ReplicationManager) SetWriteQuorum(quorum int) <span class="cov0" title="0">{
        rm.writeQuorum = quorum
        log.Printf("[REPLICATION] Write quorum set to: %d", quorum)
}</span>

func (rm *ReplicationManager) Shutdown() <span class="cov0" title="0">{
        log.Println("[REPLICATION] Shutting down...")
        rm.cancel()

        rm.peersMu.Lock()
        for _, peer := range rm.peers </span><span class="cov0" title="0">{
                peer.conn.Close()
        }</span>
        <span class="cov0" title="0">rm.peersMu.Unlock()</span>
}

func (rm *ReplicationManager) SyncFromPeer(peerID string, fromSeq uint64) error <span class="cov0" title="0">{
        rm.peersMu.RLock()
        peer, ok := rm.peers[peerID]
        rm.peersMu.RUnlock()

        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("peer not found: %s", peerID)
        }</span>

        <span class="cov0" title="0">ops := rm.opLog.GetSince(fromSeq)

        for _, op := range ops </span><span class="cov0" title="0">{
                if err := rm.sendOpToPeer(peer, op); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("sync failed at seqNum %d: %w", op.SeqNum, err)
                }</span>
        }

        <span class="cov0" title="0">log.Printf("[REPLICATION] Synced %d ops to peer %s", len(ops), peerID)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package engine

import (
        "container/list"
        "context"
        "errors"
        "fmt"
        "hash/fnv"
        "math/rand"
        "strconv"
        "sync"
        "sync/atomic"
        "time"

        "github.com/golang/snappy"
        "golang.org/x/sync/singleflight"

        "github.com/AutoCookies/pomai-cache/shared/ds/bloom"
        "github.com/AutoCookies/pomai-cache/shared/ds/sketch"
        "github.com/AutoCookies/pomai-cache/shared/ds/skiplist"
)

func init() <span class="cov8" title="1">{
        rand.Seed(time.Now().UnixNano())
}</span>

var GlobalMemCtrl *MemoryController
var GlobalFreq *sketch.Sketch

func InitGlobalFreq(width, depth uint32) <span class="cov8" title="1">{
        GlobalFreq = sketch.New(width, depth)
}</span>

type entry struct {
        key        string
        value      []byte
        size       int
        expireAt   int64
        lastAccess int64
        accesses   uint64
        createdAt  int64
}

type shard struct {
        mu    sync.RWMutex
        items map[string]*list.Element
        ll    *list.List
        bytes int64
}

type Store struct {
        shards        []*shard
        shardCount    uint32
        capacityBytes int64

        totalBytesAtomic int64
        freqBoost        int64
        hits             uint64
        misses           uint64
        evictions        uint64

        adaptiveTTL *AdaptiveTTL

        bloom      *bloom.BloomFilter
        bloomStats BloomStats

        g singleflight.Group

        zsets map[string]*skiplist.Skiplist
        zmu   sync.RWMutex

        replicationMgr *ReplicationManager
        tenantID       string

        // ✅ Eviction control (NEW)
        evictionTrigger  chan struct{}
        evictionInFlight atomic.Bool
        lastEvictionTime atomic.Int64 // unix nano
        evictionMetrics  EvictionMetrics
        evictionCtx      context.Context
        evictionCancel   context.CancelFunc

        // Thresholds
        evictionThreshold float64 // 0.8 = 80%
        evictionTarget    float64 // 0.7 = 70%
}

type BloomStats struct {
        Hits              uint64
        Misses            uint64
        Avoided           uint64
        FalsePositiveRate float64
}

// ✅ Eviction Metrics (NEW)
type EvictionMetrics struct {
        TotalEvictions       atomic.Uint64
        AsyncEvictions       atomic.Uint64
        EmergencyEvictions   atomic.Uint64
        BytesFreed           atomic.Int64
        AvgEvictionTimeMs    atomic.Int64
        LastEvictionDuration atomic.Int64
}

func NewStore(shardCount int) *Store <span class="cov8" title="1">{
        return NewStoreWithOptions(shardCount, 0)
}</span>

func NewStoreWithOptions(shardCount int, capacityBytes int64) *Store <span class="cov8" title="1">{
        if shardCount &lt;= 0 </span><span class="cov0" title="0">{
                shardCount = 256
        }</span>

        <span class="cov8" title="1">ctx, cancel := context.WithCancel(context.Background())

        s := &amp;Store{
                shards:        make([]*shard, shardCount),
                shardCount:    uint32(shardCount),
                capacityBytes: capacityBytes,
                freqBoost:     1_000_000,
                zsets:         make(map[string]*skiplist.Skiplist),
                tenantID:      "default",

                evictionTrigger:   make(chan struct{}, 1),
                evictionThreshold: 0.80,
                evictionTarget:    0.70,
                evictionCtx:       ctx,
                evictionCancel:    cancel,
        }

        for i := 0; i &lt; shardCount; i++ </span><span class="cov8" title="1">{
                s.shards[i] = &amp;shard{
                        items: make(map[string]*list.Element),
                        ll:    list.New(),
                }
        }</span>

        <span class="cov8" title="1">if capacityBytes &gt; 0 </span><span class="cov8" title="1">{
                go s.evictionWorker()
        }</span>

        <span class="cov8" title="1">return s</span>
}

func (s *Store) Shutdown() <span class="cov8" title="1">{
        if s.evictionCancel != nil </span><span class="cov8" title="1">{
                s.evictionCancel()
        }</span>
}

func (s *Store) getShard(key string) *shard <span class="cov8" title="1">{
        h := fnv.New32a()
        _, _ = h.Write([]byte(key))
        idx := h.Sum32() % s.shardCount
        return s.shards[int(idx)]
}</span>

func (s *Store) hashToShardIndex(key string) int <span class="cov8" title="1">{
        h := fnv.New32a()
        _, _ = h.Write([]byte(key))
        return int(h.Sum32() % s.shardCount)
}</span>

func (s *Store) Put(key string, value []byte, ttl time.Duration) error <span class="cov8" title="1">{
        if key == "" </span><span class="cov0" title="0">{
                return errors.New("missing key")
        }</span>

        <span class="cov8" title="1">vcopy := make([]byte, len(value))
        copy(vcopy, value)
        newSize := len(vcopy)

        now := time.Now().UnixNano()
        var expireAt int64
        if ttl &gt; 0 </span><span class="cov8" title="1">{
                expireAt = time.Now().Add(ttl).UnixNano()
        }</span>

        // ✅ Check eviction BEFORE acquiring lock
        <span class="cov8" title="1">if err := s.evictIfNeeded(s.hashToShardIndex(key)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // ✅ TinyLFU admission control
        <span class="cov8" title="1">if s.capacityBytes &gt; 0 &amp;&amp; GlobalFreq != nil </span><span class="cov8" title="1">{
                if !s.admitOrRejectTinyLFU(key, newSize) </span><span class="cov8" title="1">{
                        return fmt.Errorf("insufficient storage (TinyLFU rejected)")
                }</span>
        }

        <span class="cov8" title="1">sh := s.getShard(key)
        sh.mu.Lock()
        defer sh.mu.Unlock()

        if elem, ok := sh.items[key]; ok </span><span class="cov0" title="0">{
                // Update existing entry
                ent := elem.Value.(*entry)
                oldSize := ent.size
                delta := int64(newSize - oldSize)

                if delta &gt; 0 &amp;&amp; GlobalMemCtrl != nil &amp;&amp; !GlobalMemCtrl.Reserve(delta) </span><span class="cov0" title="0">{
                        return fmt.Errorf("insufficient storage (OOM Guard)")
                }</span>

                <span class="cov0" title="0">ent.value = vcopy
                ent.size = newSize
                ent.expireAt = expireAt
                ent.lastAccess = now
                atomic.AddUint64(&amp;ent.accesses, 1)

                sh.bytes += delta
                sh.ll.MoveToFront(elem)
                atomic.AddInt64(&amp;s.totalBytesAtomic, delta)

                if delta &lt; 0 &amp;&amp; GlobalMemCtrl != nil </span><span class="cov0" title="0">{
                        GlobalMemCtrl.Release(-delta)
                }</span>
        } else<span class="cov8" title="1"> {
                // New entry
                if GlobalMemCtrl != nil &amp;&amp; !GlobalMemCtrl.Reserve(int64(newSize)) </span><span class="cov0" title="0">{
                        // ✅ Emergency eviction if global memory exhausted
                        if err := s.emergencyEvict(int64(newSize)); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("insufficient storage (OOM Guard)")
                        }</span>

                        // Retry reserve
                        <span class="cov0" title="0">if !GlobalMemCtrl.Reserve(int64(newSize)) </span><span class="cov0" title="0">{
                                return fmt.Errorf("insufficient storage (OOM Guard)")
                        }</span>
                }

                <span class="cov8" title="1">ent := &amp;entry{
                        key:        key,
                        value:      vcopy,
                        size:       newSize,
                        expireAt:   expireAt,
                        lastAccess: now,
                        accesses:   1,
                        createdAt:  now,
                }

                elem := sh.ll.PushFront(ent)
                sh.items[key] = elem
                sh.bytes += int64(newSize)
                atomic.AddInt64(&amp;s.totalBytesAtomic, int64(newSize))

                if s.bloom != nil </span><span class="cov0" title="0">{
                        s.bloom.Add(key)
                }</span>
        }

        <span class="cov8" title="1">if GlobalFreq != nil </span><span class="cov8" title="1">{
                GlobalFreq.Increment(key)
        }</span>

        <span class="cov8" title="1">s.replicateOp(OpTypeSet, key, vcopy, 0, ttl)

        return nil</span>
}

func (s *Store) Get(key string) ([]byte, bool) <span class="cov8" title="1">{
        if key == "" </span><span class="cov0" title="0">{
                atomic.AddUint64(&amp;s.misses, 1)
                return nil, false
        }</span>

        <span class="cov8" title="1">if s.bloom != nil &amp;&amp; !s.bloom.MayContain(key) </span><span class="cov0" title="0">{
                atomic.AddUint64(&amp;s.misses, 1)
                atomic.AddUint64(&amp;s.bloomStats.Avoided, 1)
                return nil, false
        }</span>

        <span class="cov8" title="1">sh := s.getShard(key)

        sh.mu.RLock()
        elem, ok := sh.items[key]
        if !ok </span><span class="cov8" title="1">{
                sh.mu.RUnlock()
                atomic.AddUint64(&amp;s.misses, 1)
                if s.bloom != nil </span><span class="cov0" title="0">{
                        atomic.AddUint64(&amp;s.bloomStats.Misses, 1)
                }</span>
                <span class="cov8" title="1">return nil, false</span>
        }
        <span class="cov8" title="1">if s.bloom != nil </span><span class="cov0" title="0">{
                atomic.AddUint64(&amp;s.bloomStats.Hits, 1)
        }</span>

        <span class="cov8" title="1">ent := elem.Value.(*entry)

        if ent.expireAt != 0 &amp;&amp; time.Now().UnixNano() &gt; ent.expireAt </span><span class="cov8" title="1">{
                sh.mu.RUnlock()
                s.deleteExpired(key)
                atomic.AddUint64(&amp;s.misses, 1)
                return nil, false
        }</span>

        <span class="cov8" title="1">val := make([]byte, len(ent.value))
        copy(val, ent.value)
        sh.mu.RUnlock()

        sh.mu.Lock()
        if elem, ok := sh.items[key]; ok </span><span class="cov8" title="1">{
                ent := elem.Value.(*entry)
                ent.lastAccess = time.Now().UnixNano()
                atomic.AddUint64(&amp;ent.accesses, 1)
                sh.ll.MoveToFront(elem)
        }</span>
        <span class="cov8" title="1">sh.mu.Unlock()

        if GlobalFreq != nil </span><span class="cov8" title="1">{
                GlobalFreq.Increment(key)
        }</span>

        <span class="cov8" title="1">atomic.AddUint64(&amp;s.hits, 1)
        return val, true</span>
}

func (s *Store) Delete(key string) <span class="cov8" title="1">{
        if key == "" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">sh := s.getShard(key)
        sh.mu.Lock()
        defer sh.mu.Unlock()

        if elem, ok := sh.items[key]; ok </span><span class="cov8" title="1">{
                ent := elem.Value.(*entry)
                delete(sh.items, key)
                sh.ll.Remove(elem)

                sh.bytes -= int64(ent.size)
                atomic.AddInt64(&amp;s.totalBytesAtomic, -int64(ent.size))
                if GlobalMemCtrl != nil </span><span class="cov0" title="0">{
                        GlobalMemCtrl.Release(int64(ent.size))
                }</span>

                <span class="cov8" title="1">s.replicateOp(OpTypeDelete, key, nil, 0, 0)</span>
        }
}

func (s *Store) Incr(key string, delta int64) (int64, error) <span class="cov0" title="0">{
        if key == "" </span><span class="cov0" title="0">{
                return 0, errors.New("missing key")
        }</span>

        <span class="cov0" title="0">sh := s.getShard(key)
        sh.mu.Lock()
        defer sh.mu.Unlock()

        var currentVal int64 = 0

        if elem, ok := sh.items[key]; ok </span><span class="cov0" title="0">{
                ent := elem.Value.(*entry)

                raw := ent.value
                var valStr string
                if len(raw) &gt; 0 </span><span class="cov0" title="0">{
                        magic := raw[0]
                        payload := raw[1:]
                        if magic == 1 </span><span class="cov0" title="0">{
                                decoded, err := snappy.Decode(nil, payload)
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, fmt.Errorf("corrupted data")
                                }</span>
                                <span class="cov0" title="0">valStr = string(decoded)</span>
                        } else<span class="cov0" title="0"> {
                                valStr = string(payload)
                        }</span>
                }

                <span class="cov0" title="0">val, err := strconv.ParseInt(valStr, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("value is not an integer")
                }</span>
                <span class="cov0" title="0">currentVal = val</span>
        }

        <span class="cov0" title="0">newVal := currentVal + delta

        newValBytes := []byte(strconv.FormatInt(newVal, 10))
        finalData := make([]byte, len(newValBytes)+1)
        finalData[0] = 0
        copy(finalData[1:], newValBytes)

        newSize := len(finalData)

        if elem, ok := sh.items[key]; ok </span><span class="cov0" title="0">{
                ent := elem.Value.(*entry)
                oldSize := ent.size
                deltaSize := int64(newSize - oldSize)

                if deltaSize &gt; 0 &amp;&amp; GlobalMemCtrl != nil &amp;&amp; !GlobalMemCtrl.Reserve(deltaSize) </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("insufficient storage")
                }</span>

                <span class="cov0" title="0">ent.value = finalData
                ent.size = newSize
                sh.bytes += deltaSize
                atomic.AddInt64(&amp;s.totalBytesAtomic, deltaSize)
                sh.ll.MoveToFront(elem)

                if deltaSize &lt; 0 &amp;&amp; GlobalMemCtrl != nil </span><span class="cov0" title="0">{
                        GlobalMemCtrl.Release(-deltaSize)
                }</span>
        } else<span class="cov0" title="0"> {
                ent := &amp;entry{
                        key:        key,
                        value:      finalData,
                        size:       newSize,
                        expireAt:   0,
                        lastAccess: time.Now().UnixNano(),
                        accesses:   1,
                        createdAt:  time.Now().UnixNano(),
                }

                if GlobalMemCtrl != nil &amp;&amp; !GlobalMemCtrl.Reserve(int64(newSize)) </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("insufficient storage")
                }</span>

                <span class="cov0" title="0">elem := sh.ll.PushFront(ent)
                sh.items[key] = elem
                sh.bytes += int64(newSize)
                atomic.AddInt64(&amp;s.totalBytesAtomic, int64(newSize))

                if s.bloom != nil </span><span class="cov0" title="0">{
                        s.bloom.Add(key)
                }</span>
        }

        <span class="cov0" title="0">s.replicateOp(OpTypeIncr, key, nil, delta, 0)

        return newVal, nil</span>
}

func (s *Store) SetReplicationManager(rm *ReplicationManager) <span class="cov0" title="0">{
        s.replicationMgr = rm
}</span>

func (s *Store) SetTenantID(tenantID string) <span class="cov0" title="0">{
        if tenantID == "" </span><span class="cov0" title="0">{
                tenantID = "default"
        }</span>
        <span class="cov0" title="0">s.tenantID = tenantID</span>
}

func (s *Store) replicateOp(opType OpType, key string, value []byte, delta int64, ttl time.Duration) <span class="cov8" title="1">{
        if s.replicationMgr == nil || !s.replicationMgr.isLeader.Load() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">op := ReplicaOp{
                Type:      opType,
                Key:       key,
                Value:     value,
                Delta:     delta,
                TTL:       ttl,
                TenantID:  s.tenantID,
                Timestamp: time.Now().UnixNano(),
        }

        go func() </span><span class="cov0" title="0">{
                _ = s.replicationMgr.Replicate(op)
        }</span>()
}

func (s *Store) MGet(keys []string) map[string][]byte <span class="cov0" title="0">{
        if len(keys) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">results := make(map[string][]byte, len(keys))

        for _, key := range keys </span><span class="cov0" title="0">{
                if val, ok := s.Get(key); ok </span><span class="cov0" title="0">{
                        results[key] = val
                }</span>
        }

        <span class="cov0" title="0">return results</span>
}

func (s *Store) MSet(items map[string][]byte, ttl time.Duration) error <span class="cov0" title="0">{
        if len(items) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for key, val := range items </span><span class="cov0" title="0">{
                if err := s.Put(key, val, ttl); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("mset failed at key %s: %w", key, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *Store) EvictionStats() EvictionMetrics <span class="cov0" title="0">{
        return s.evictionMetrics
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package engine

import (
        "errors"
        "fmt"
        "log"
        "math/rand"
        "sort"
        "sync/atomic"
        "time"
)

var (
        ErrInsufficientStorage = errors.New("insufficient storage after eviction attempts")
        ErrTinyLFURejected     = errors.New("tiny-lfu admission control rejected")
)

var evictionLogEnabled atomic.Bool

func init() <span class="cov8" title="1">{
        evictionLogEnabled.Store(true) // Default enabled
}</span>

func SetEvictionLogging(enabled bool) <span class="cov8" title="1">{
        evictionLogEnabled.Store(enabled)
}</span>

func logEviction(format string, args ...interface{}) <span class="cov8" title="1">{
        if evictionLogEnabled.Load() </span><span class="cov8" title="1">{
                log.Printf("[EVICTION] "+format, args...)
        }</span>
}

type victimCandidate struct {
        key  string
        size int
        freq uint32
}

func (s *Store) evictIfNeeded(startShard int) error <span class="cov8" title="1">{
        if s.capacityBytes &lt;= 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">currentBytes := atomic.LoadInt64(&amp;s.totalBytesAtomic)
        usageRatio := float64(currentBytes) / float64(s.capacityBytes)

        if usageRatio &lt; s.evictionThreshold </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if usageRatio &gt;= 1.0 </span><span class="cov8" title="1">{
                s.evictionMetrics.EmergencyEvictions.Add(1)
                return s.emergencyEvict(currentBytes - s.capacityBytes)
        }</span>

        <span class="cov8" title="1">s.triggerAsyncEviction()

        return nil</span>
}

func (s *Store) triggerAsyncEviction() <span class="cov8" title="1">{
        if !s.evictionInFlight.CompareAndSwap(false, true) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">select </span>{
        case s.evictionTrigger &lt;- struct{}{}:<span class="cov8" title="1">
                s.evictionMetrics.AsyncEvictions.Add(1)</span>
        default:<span class="cov0" title="0">
                s.evictionInFlight.Store(false)</span>
        }
}

func (s *Store) evictionWorker() <span class="cov8" title="1">{
        logEviction("Worker started for tenant=%s (threshold:  %. 0f%%, target: %.0f%%)",
                s.tenantID, s.evictionThreshold*100, s.evictionTarget*100)

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-s.evictionCtx.Done():<span class="cov8" title="1">
                        logEviction("Worker stopped for tenant=%s", s.tenantID)
                        return</span>

                case &lt;-s.evictionTrigger:<span class="cov8" title="1">
                        start := time.Now()

                        currentBytes := atomic.LoadInt64(&amp;s.totalBytesAtomic)
                        targetBytes := int64(float64(s.capacityBytes) * s.evictionTarget)
                        toFree := currentBytes - targetBytes

                        if toFree &lt;= 0 </span><span class="cov0" title="0">{
                                s.evictionInFlight.Store(false)
                                continue</span>
                        }

                        <span class="cov8" title="1">freed := s.batchEvict(toFree)
                        duration := time.Since(start)

                        s.evictionInFlight.Store(false)
                        s.lastEvictionTime.Store(time.Now().UnixNano())
                        s.evictionMetrics.LastEvictionDuration.Store(duration.Milliseconds())

                        if freed &gt; 0 </span><span class="cov8" title="1">{
                                s.evictionMetrics.BytesFreed.Add(freed)
                                s.evictionMetrics.TotalEvictions.Add(1)

                                totalEvictions := s.evictionMetrics.TotalEvictions.Load()
                                if totalEvictions &gt; 0 </span><span class="cov8" title="1">{
                                        avgTime := (s.evictionMetrics.AvgEvictionTimeMs.Load()*int64(totalEvictions-1) +
                                                duration.Milliseconds()) / int64(totalEvictions)
                                        s.evictionMetrics.AvgEvictionTimeMs.Store(avgTime)
                                }</span>

                                <span class="cov8" title="1">logEviction("tenant=%s freed=%s target=%s duration=%v usage=%.1f%%",
                                        s.tenantID, formatBytes(freed), formatBytes(toFree), duration,
                                        float64(atomic.LoadInt64(&amp;s.totalBytesAtomic))/float64(s.capacityBytes)*100)</span>
                        }
                }
        }
}

func (s *Store) batchEvict(targetBytes int64) int64 <span class="cov8" title="1">{
        if targetBytes &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">estimatedCount := int(targetBytes / 1024)
        if estimatedCount &lt; 100 </span><span class="cov8" title="1">{
                estimatedCount = 100
        }</span>
        <span class="cov8" title="1">if estimatedCount &gt; 10000 </span><span class="cov0" title="0">{
                estimatedCount = 10000
        }</span>

        <span class="cov8" title="1">victims := s.collectVictimsBatch(estimatedCount)

        if len(victims) == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">sort.Slice(victims, func(i, j int) bool </span><span class="cov8" title="1">{
                return victims[i].freq &lt; victims[j].freq
        }</span>)

        <span class="cov8" title="1">freed := int64(0)
        evictedCount := 0

        for _, v := range victims </span><span class="cov8" title="1">{
                if freed &gt;= targetBytes </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">size := s.evictKey(v.key)
                if size &gt; 0 </span><span class="cov8" title="1">{
                        freed += int64(size)
                        evictedCount++
                        atomic.AddInt64(&amp;s.totalBytesAtomic, -int64(size))
                }</span>
        }

        <span class="cov8" title="1">if evictedCount &gt; 0 </span><span class="cov8" title="1">{
                logEviction("Batch evicted %d items, freed %s", evictedCount, formatBytes(freed))
        }</span>

        <span class="cov8" title="1">return freed</span>
}

func (s *Store) collectVictimsBatch(estimatedCount int) []victimCandidate <span class="cov8" title="1">{
        victims := make([]victimCandidate, 0, estimatedCount)
        shardCount := int(s.shardCount)

        samplesPerShard := max(1, estimatedCount/shardCount)

        for i := 0; i &lt; shardCount; i++ </span><span class="cov8" title="1">{
                sh := s.shards[i]

                sh.mu.RLock()
                elem := sh.ll.Back()
                count := 0

                for elem != nil &amp;&amp; count &lt; samplesPerShard </span><span class="cov8" title="1">{
                        ent := elem.Value.(*entry)

                        if ent.expireAt != 0 &amp;&amp; time.Now().UnixNano() &gt; ent.expireAt </span><span class="cov8" title="1">{
                                elem = elem.Prev()
                                continue</span>
                        }

                        <span class="cov8" title="1">freq := uint32(0)
                        if GlobalFreq != nil </span><span class="cov8" title="1">{
                                freq = GlobalFreq.Estimate(ent.key)
                        }</span>

                        <span class="cov8" title="1">victims = append(victims, victimCandidate{
                                key:  ent.key,
                                size: ent.size,
                                freq: freq,
                        })

                        elem = elem.Prev()
                        count++</span>
                }
                <span class="cov8" title="1">sh.mu.RUnlock()</span>
        }

        <span class="cov8" title="1">return victims</span>
}

func (s *Store) emergencyEvict(targetBytes int64) error <span class="cov8" title="1">{
        const maxAttempts = 3

        logEviction("EMERGENCY tenant=%s need_to_free=%s", s.tenantID, formatBytes(targetBytes))

        for attempt := 0; attempt &lt; maxAttempts; attempt++ </span><span class="cov8" title="1">{
                freed := s.batchEvict(targetBytes)

                if freed &gt;= targetBytes </span><span class="cov8" title="1">{
                        logEviction("EMERGENCY tenant=%s freed=%s attempt=%d",
                                s.tenantID, formatBytes(freed), attempt+1)
                        return nil
                }</span>

                <span class="cov8" title="1">targetBytes -= freed

                if attempt == maxAttempts-1 </span><span class="cov8" title="1">{
                        freed = s.ForceEvictBytes(targetBytes)
                        if freed &gt; 0 </span><span class="cov8" title="1">{
                                logEviction("EMERGENCY tenant=%s force_freed=%s",
                                        s.tenantID, formatBytes(freed))
                                return nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return ErrInsufficientStorage</span>
}

func (s *Store) evictKey(key string) int <span class="cov8" title="1">{
        if key == "" </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">sh := s.getShard(key)
        sh.mu.Lock()
        defer sh.mu.Unlock()

        elem, ok := sh.items[key]
        if !ok </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">ent := elem.Value.(*entry)
        size := ent.size

        delete(sh.items, key)
        sh.ll.Remove(elem)

        sh.bytes -= int64(size)
        atomic.AddUint64(&amp;s.evictions, 1)

        if GlobalMemCtrl != nil </span><span class="cov0" title="0">{
                GlobalMemCtrl.Release(int64(size))
        }</span>

        <span class="cov8" title="1">return size</span>
}

func (s *Store) admitOrRejectTinyLFU(key string, newSize int) bool <span class="cov8" title="1">{
        if s.capacityBytes == 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">if atomic.LoadInt64(&amp;s.totalBytesAtomic)+int64(newSize) &lt;= s.capacityBytes </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if GlobalFreq == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">newFreq := GlobalFreq.Estimate(key) + 1

        const maxAttempts = 3
        for i := 0; i &lt; maxAttempts; i++ </span><span class="cov8" title="1">{
                victimKey, _, victimFreq := s.sampleVictim()

                if victimKey == "" </span><span class="cov8" title="1">{
                        return true
                }</span>

                <span class="cov8" title="1">if newFreq &gt;= victimFreq </span><span class="cov8" title="1">{
                        freed := s.evictKey(victimKey)
                        if freed &gt; 0 </span><span class="cov8" title="1">{
                                atomic.AddInt64(&amp;s.totalBytesAtomic, -int64(freed))

                                if atomic.LoadInt64(&amp;s.totalBytesAtomic)+int64(newSize) &lt;= s.capacityBytes </span><span class="cov8" title="1">{
                                        return true
                                }</span>
                                <span class="cov8" title="1">continue</span>
                        }
                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov8" title="1">return false</span>
        }

        <span class="cov8" title="1">return atomic.LoadInt64(&amp;s.totalBytesAtomic)+int64(newSize) &lt;= s.capacityBytes</span>
}

func (s *Store) sampleVictim() (string, int, uint32) <span class="cov8" title="1">{
        shardCount := int(s.shardCount)
        if shardCount == 0 </span><span class="cov0" title="0">{
                return "", 0, 0
        }</span>

        <span class="cov8" title="1">const (
                sampleShardLimit = 8
                perShardSamples  = 1
        )

        var bestKey string
        var bestSize int
        var bestFreq uint32 = ^uint32(0)

        for i := 0; i &lt; sampleShardLimit; i++ </span><span class="cov8" title="1">{
                idx := rand.Intn(shardCount)
                sh := s.shards[idx]

                sh.mu.RLock()
                elem := sh.ll.Back()
                count := 0

                for elem != nil &amp;&amp; count &lt; perShardSamples </span><span class="cov8" title="1">{
                        ent := elem.Value.(*entry)

                        if ent.expireAt != 0 &amp;&amp; time.Now().UnixNano() &gt; ent.expireAt </span><span class="cov8" title="1">{
                                elem = elem.Prev()
                                continue</span>
                        }

                        <span class="cov8" title="1">freq := uint32(0)
                        if GlobalFreq != nil </span><span class="cov8" title="1">{
                                freq = GlobalFreq.Estimate(ent.key)
                        }</span>

                        <span class="cov8" title="1">if freq &lt; bestFreq </span><span class="cov8" title="1">{
                                bestFreq = freq
                                bestKey = ent.key
                                bestSize = ent.size
                        }</span>

                        <span class="cov8" title="1">elem = elem.Prev()
                        count++</span>
                }
                <span class="cov8" title="1">sh.mu.RUnlock()</span>
        }

        <span class="cov8" title="1">if bestKey == "" </span><span class="cov8" title="1">{
                return "", 0, 0
        }</span>
        <span class="cov8" title="1">return bestKey, bestSize, bestFreq</span>
}

func (s *Store) ForceEvictBytes(targetBytes int64) int64 <span class="cov8" title="1">{
        if targetBytes &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">freed := int64(0)
        shardCount := int(s.shardCount)

        for i := 0; i &lt; shardCount &amp;&amp; freed &lt; targetBytes; i++ </span><span class="cov8" title="1">{
                sh := s.shards[i]
                sh.mu.Lock()

                for elem := sh.ll.Back(); elem != nil &amp;&amp; freed &lt; targetBytes; </span><span class="cov8" title="1">{
                        ent := elem.Value.(*entry)
                        prev := elem.Prev()

                        delete(sh.items, ent.key)
                        sh.ll.Remove(elem)

                        size := int64(ent.size)
                        sh.bytes -= size
                        atomic.AddUint64(&amp;s.evictions, 1)

                        freed += size
                        elem = prev
                }</span>
                <span class="cov8" title="1">sh.mu.Unlock()</span>
        }

        <span class="cov8" title="1">if freed &gt; 0 </span><span class="cov8" title="1">{
                atomic.AddInt64(&amp;s.totalBytesAtomic, -freed)
                if GlobalMemCtrl != nil </span><span class="cov0" title="0">{
                        GlobalMemCtrl.Release(freed)
                }</span>
        }

        <span class="cov8" title="1">return freed</span>
}

// Legacy functions (kept for backward compatibility)
func (s *Store) collectCandidates(start, shardLimit, samplesPerShard, maxCands int) []candidate <span class="cov0" title="0">{
        cands := make([]candidate, 0, 32)
        shardCount := int(s.shardCount)

        for i := 0; i &lt; shardLimit &amp;&amp; len(cands) &lt; maxCands; i++ </span><span class="cov0" title="0">{
                idx := (start + i) % shardCount
                sh := s.shards[idx]

                sh.mu.RLock()
                elem := sh.ll.Back()
                count := 0

                for elem != nil &amp;&amp; count &lt; samplesPerShard &amp;&amp; len(cands) &lt; maxCands </span><span class="cov0" title="0">{
                        ent := elem.Value.(*entry)
                        priority := ent.lastAccess + int64(atomic.LoadUint64(&amp;ent.accesses))*atomic.LoadInt64(&amp;s.freqBoost)

                        cands = append(cands, candidate{
                                shardIdx: idx,
                                key:      ent.key,
                                priority: priority,
                                size:     ent.size,
                        })

                        elem = elem.Prev()
                        count++
                }</span>
                <span class="cov0" title="0">sh.mu.RUnlock()</span>
        }

        <span class="cov0" title="0">return cands</span>
}

func (s *Store) selectVictim(cands []candidate) candidate <span class="cov0" title="0">{
        if len(cands) == 0 </span><span class="cov0" title="0">{
                return candidate{}
        }</span>

        <span class="cov0" title="0">best := cands[0]
        for _, c := range cands[1:] </span><span class="cov0" title="0">{
                if c.priority &lt; best.priority </span><span class="cov0" title="0">{
                        best = c
                }</span>
        }

        <span class="cov0" title="0">return best</span>
}

func (s *Store) reserveSpace(newSize int) error <span class="cov0" title="0">{
        if s.capacityBytes == 0 </span><span class="cov0" title="0">{
                if GlobalMemCtrl != nil </span><span class="cov0" title="0">{
                        if !GlobalMemCtrl.Reserve(int64(newSize)) </span><span class="cov0" title="0">{
                                return ErrInsufficientStorage
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">maxRetries := 5
        for retry := 0; retry &lt; maxRetries; retry++ </span><span class="cov0" title="0">{
                currentBytes := atomic.LoadInt64(&amp;s.totalBytesAtomic)
                projectedBytes := currentBytes + int64(newSize)

                if projectedBytes &lt;= s.capacityBytes </span><span class="cov0" title="0">{
                        if GlobalMemCtrl != nil </span><span class="cov0" title="0">{
                                if !GlobalMemCtrl.Reserve(int64(newSize)) </span><span class="cov0" title="0">{
                                        return ErrInsufficientStorage
                                }</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">if err := s.evictIfNeeded(rand.Intn(int(s.shardCount))); err != nil </span><span class="cov0" title="0">{
                        if retry == maxRetries-1 </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
        }

        <span class="cov0" title="0">return ErrInsufficientStorage</span>
}

func (s *Store) tryReserveWithEviction(newSize int) error <span class="cov0" title="0">{
        if err := s.reserveSpace(newSize); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">newBytes := atomic.AddInt64(&amp;s.totalBytesAtomic, int64(newSize))

        if s.capacityBytes &gt; 0 &amp;&amp; newBytes &gt; s.capacityBytes </span><span class="cov0" title="0">{
                atomic.AddInt64(&amp;s.totalBytesAtomic, -int64(newSize))

                if GlobalMemCtrl != nil </span><span class="cov0" title="0">{
                        GlobalMemCtrl.Release(int64(newSize))
                }</span>

                <span class="cov0" title="0">return ErrInsufficientStorage</span>
        }

        <span class="cov0" title="0">return nil</span>
}

type candidate struct {
        shardIdx int
        key      string
        priority int64
        size     int
}

func max(a, b int) int <span class="cov8" title="1">{
        if a &gt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

func formatBytes(bytes int64) string <span class="cov8" title="1">{
        const unit = 1024
        if bytes &lt; unit </span><span class="cov8" title="1">{
                return fmt.Sprintf("%d B", bytes)
        }</span>
        <span class="cov8" title="1">div, exp := int64(unit), 0
        for n := bytes / unit; n &gt;= unit; n /= unit </span><span class="cov8" title="1">{
                div *= unit
                exp++
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package engine

import (
        "context"
        "time"
)

// GetOrLoad gộp các request concurrent cùng key lại thành 1 (Request Coalescing).
// Kỹ thuật này giúp chống "Thundering Herd" (Đám đông giẫm đạp) khi Cache Miss.
//
// Cơ chế:
// 1. Nếu 100 request cùng hỏi key "A" và cache miss.
// 2. Chỉ 1 request được phép chạy hàm loader (gọi DB/API).
// 3. 99 request còn lại chờ.
// 4. Khi loader xong, kết quả trả về cho cả 100 request cùng lúc.
func (s *Store) GetOrLoad(ctx context.Context, key string, loader func(context.Context) ([]byte, time.Duration, error)) ([]byte, bool, error) <span class="cov8" title="1">{
        if key == "" </span><span class="cov0" title="0">{
                return nil, false, nil
        }</span>

        // 1. Fast path: Kiểm tra cache trước
        <span class="cov8" title="1">if v, ok := s.Get(key); ok </span><span class="cov0" title="0">{
                return v, true, nil
        }</span>

        // 2. Dùng Singleflight để gộp request
        // Sử dụng DoChan để hỗ trợ Context Cancellation (nếu client hủy request thì ta hủy theo)
        <span class="cov8" title="1">resCh := s.g.DoChan(key, func() (interface{}, error) </span><span class="cov8" title="1">{
                // Gọi loader (Hàm lấy dữ liệu từ nguồn gốc - DB/API)
                v, ttl, err := loader(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Best-effort: Lưu vào cache.
                // Bỏ qua lỗi (ví dụ đầy bộ nhớ) để ưu tiên trả dữ liệu cho user.
                <span class="cov8" title="1">_ = s.Put(key, v, ttl)

                return v, nil</span>
        })

        <span class="cov8" title="1">select </span>{
        case r := &lt;-resCh:<span class="cov8" title="1">
                if r.Err != nil </span><span class="cov0" title="0">{
                        return nil, false, r.Err
                }</span>
                // Ép kiểu dữ liệu trả về
                <span class="cov8" title="1">if data, ok := r.Val.([]byte); ok </span><span class="cov8" title="1">{
                        return data, true, nil
                }</span>
                <span class="cov0" title="0">return nil, false, nil</span>

        case &lt;-ctx.Done():<span class="cov0" title="0">
                // Nếu context timeout hoặc cancel
                return nil, false, ctx.Err()</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package engine

import (
        "encoding/gob"
        "errors"
        "io"
        "sync/atomic"
        "time"

        "github.com/AutoCookies/pomai-cache/shared/ds/skiplist"
)

// snapshotItem là struct trung gian dùng để encode/decode dữ liệu.
// Nó hỗ trợ cả Key-Value truyền thống và ZSet (Sorted Set).
type snapshotItem struct {
        Type uint8 // 0 = KV (Key-Value), 1 = ZSet (Sorted Set)

        // Fields cho KV
        Key        string
        Value      []byte
        ExpireAt   int64
        LastAccess int64
        Accesses   uint64
        CreatedAt  int64

        // Fields cho ZSet
        ZMembers []snapshotZMember
}

// snapshotZMember struct con để lưu từng phần tử trong ZSet
type snapshotZMember struct {
        Member string
        Score  float64
}

// SnapshotTo ghi toàn bộ dữ liệu cache (KV + ZSet) vào writer.
func (s *Store) SnapshotTo(w io.Writer) error <span class="cov8" title="1">{
        enc := gob.NewEncoder(w)

        // 1. Ghi Version. Sử dụng version 2 để đánh dấu hỗ trợ ZSet.
        if err := enc.Encode(int(2)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 2. Snapshot KV Data (Shards)
        <span class="cov8" title="1">for _, sh := range s.shards </span><span class="cov8" title="1">{
                sh.mu.RLock()
                for _, elem := range sh.items </span><span class="cov8" title="1">{
                        ent := elem.Value.(*entry)

                        // Bỏ qua key hết hạn
                        if ent.expireAt != 0 &amp;&amp; time.Now().UnixNano() &gt; ent.expireAt </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">item := snapshotItem{
                                Type:       0, // KV
                                Key:        ent.key,
                                Value:      ent.value,
                                ExpireAt:   ent.expireAt,
                                LastAccess: ent.lastAccess,
                                Accesses:   atomic.LoadUint64(&amp;ent.accesses),
                                CreatedAt:  ent.createdAt,
                        }

                        if err := enc.Encode(&amp;item); err != nil </span><span class="cov0" title="0">{
                                sh.mu.RUnlock()
                                return err
                        }</span>
                }
                <span class="cov8" title="1">sh.mu.RUnlock()</span>
        }

        // 3. Snapshot ZSet Data
        // Cần Lock toàn bộ map ZSet để đọc
        <span class="cov8" title="1">s.zmu.RLock()
        defer s.zmu.RUnlock()

        for key, sl := range s.zsets </span><span class="cov8" title="1">{
                // Lấy toàn bộ dữ liệu từ Skiplist
                // LƯU Ý: Bạn cần đảm bảo pkg/ds/skiplist có method Dump() trả về danh sách node.
                // Nếu chưa có, xem phần chú thích bên dưới để thêm vào.
                nodes := sl.Dump()

                zMembers := make([]snapshotZMember, len(nodes))
                for i, n := range nodes </span><span class="cov8" title="1">{
                        zMembers[i] = snapshotZMember{
                                Member: n.Member,
                                Score:  n.Score,
                        }
                }</span>

                <span class="cov8" title="1">item := snapshotItem{
                        Type:     1, // ZSet
                        Key:      key,
                        ZMembers: zMembers,
                }

                if err := enc.Encode(&amp;item); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// RestoreFrom khôi phục dữ liệu từ reader.
func (s *Store) RestoreFrom(r io.Reader) error <span class="cov8" title="1">{
        dec := gob.NewDecoder(r)

        // 1. Check Version
        var version int
        if err := dec.Decode(&amp;version); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Hỗ trợ cả version 1 (cũ) và 2 (mới)
        <span class="cov8" title="1">if version != 1 &amp;&amp; version != 2 </span><span class="cov0" title="0">{
                return errors.New("unsupported snapshot version")
        }</span>

        // 2. Loop đọc từng item
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                var item snapshotItem
                if err := dec.Decode(&amp;item); err != nil </span><span class="cov8" title="1">{
                        if err == io.EOF </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov0" title="0">return err</span>
                }

                <span class="cov8" title="1">if item.Type == 0 </span><span class="cov8" title="1">{
                        // --- RESTORE KV ---
                        if item.ExpireAt != 0 &amp;&amp; time.Now().UnixNano() &gt; item.ExpireAt </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">sh := s.getShard(item.Key)
                        sh.mu.Lock()

                        // Xóa cũ nếu đè
                        if elem, ok := sh.items[item.Key]; ok </span><span class="cov0" title="0">{
                                old := elem.Value.(*entry)
                                delete(sh.items, item.Key)
                                sh.ll.Remove(elem)
                                sh.bytes -= int64(old.size)
                                atomic.AddInt64(&amp;s.totalBytesAtomic, -int64(old.size))
                        }</span>

                        <span class="cov8" title="1">ent := &amp;entry{
                                key:        item.Key,
                                value:      item.Value,
                                size:       len(item.Value),
                                expireAt:   item.ExpireAt,
                                lastAccess: item.LastAccess,
                                accesses:   item.Accesses,
                                createdAt:  item.CreatedAt,
                        }

                        elem := sh.ll.PushFront(ent)
                        sh.items[item.Key] = elem
                        sh.bytes += int64(ent.size)
                        atomic.AddInt64(&amp;s.totalBytesAtomic, int64(ent.size))

                        // Rebuild Bloom Filter
                        if s.bloom != nil </span><span class="cov0" title="0">{
                                s.bloom.Add(item.Key)
                        }</span>
                        <span class="cov8" title="1">sh.mu.Unlock()</span>

                } else<span class="cov8" title="1"> if item.Type == 1 </span><span class="cov8" title="1">{
                        // --- RESTORE ZSET ---
                        // Vì ZSet ít khi bị expire hơn và cơ chế phức tạp hơn, ta restore thẳng
                        s.zmu.Lock()

                        // Lazy init map nếu chưa có
                        if s.zsets == nil </span><span class="cov0" title="0">{
                                s.zsets = make(map[string]*skiplist.Skiplist)
                        }</span>

                        // Tạo mới Skiplist
                        <span class="cov8" title="1">sl := skiplist.New()
                        for _, m := range item.ZMembers </span><span class="cov8" title="1">{
                                sl.Add(m.Member, m.Score)
                        }</span>
                        <span class="cov8" title="1">s.zsets[item.Key] = sl

                        s.zmu.Unlock()</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package engine

import (
        "sync/atomic"
        "time"
)

// Stats là struct chứa báo cáo tổng quan về Cache
// Được trả về qua API /stats
type Stats struct {
        // Core Metrics
        Hits       uint64 `json:"hits"`
        Misses     uint64 `json:"misses"`
        Items      int64  `json:"items"`
        Bytes      int64  `json:"bytes"`
        Capacity   int64  `json:"capacity"`
        Evictions  uint64 `json:"evictions"`
        ShardCount int    `json:"shard_count"`
        FreqBoost  int64  `json:"freq_boost"`

        // Cache Performance
        HitRate      float64 `json:"hit_rate"`
        MissRate     float64 `json:"miss_rate"`
        UsagePercent float64 `json:"usage_percent"`
        AvgItemSize  int64   `json:"avg_item_size_bytes"`

        // Adaptive TTL Info
        AdaptiveTTL    bool   `json:"adaptive_ttl_enabled"`
        AdaptiveMinTTL string `json:"adaptive_min_ttl,omitempty"`
        AdaptiveMaxTTL string `json:"adaptive_max_ttl,omitempty"`

        // Bloom Filter Info
        BloomEnabled bool    `json:"bloom_enabled"`
        BloomFPRate  float64 `json:"bloom_false_positive_rate"`
        BloomAvoided uint64  `json:"bloom_avoided_lookups"`

        EvictionStats EvictionStatsJSON `json:"eviction_stats"`

        // Tenant Info
        TenantID string `json:"tenant_id"`
}

type EvictionStatsJSON struct {
        // Counters
        TotalEvictions     uint64 `json:"total_evictions"`
        AsyncEvictions     uint64 `json:"async_evictions"`
        EmergencyEvictions uint64 `json:"emergency_evictions"`
        BytesFreed         int64  `json:"bytes_freed"`

        // Timing
        AvgEvictionTimeMs int64  `json:"avg_eviction_time_ms"`
        LastEvictionMs    int64  `json:"last_eviction_time_ms"`
        LastEvictionAt    string `json:"last_eviction_at,omitempty"`

        // State
        InFlight          bool    `json:"in_flight"`
        EvictionThreshold float64 `json:"eviction_threshold_percent"`
        EvictionTarget    float64 `json:"eviction_target_percent"`

        // Efficiency
        EvictionRate        float64 `json:"eviction_rate"` // evictions per second
        AvgBytesPerEviction int64   `json:"avg_bytes_per_eviction"`
}

// Stats thu thập dữ liệu từ tất cả các Shard và Atomic Counters
func (s *Store) Stats() Stats <span class="cov8" title="1">{
        var totalItems int64
        var totalBytes int64

        // 1. Duyệt qua từng shard để cộng dồn items và bytes
        for _, sh := range s.shards </span><span class="cov8" title="1">{
                sh.mu.RLock()
                totalItems += int64(len(sh.items))
                totalBytes += sh.bytes
                sh.mu.RUnlock()
        }</span>

        // 2. Lấy số liệu Bloom Filter
        <span class="cov8" title="1">bloomStats := s.GetBloomStats()

        evictionStats := s.GetEvictionStats()

        // 4. Tính toán các metric phái sinh
        hits := atomic.LoadUint64(&amp;s.hits)
        misses := atomic.LoadUint64(&amp;s.misses)
        totalRequests := hits + misses

        hitRate := 0.0
        missRate := 0.0
        if totalRequests &gt; 0 </span><span class="cov8" title="1">{
                hitRate = float64(hits) / float64(totalRequests) * 100
                missRate = float64(misses) / float64(totalRequests) * 100
        }</span>

        <span class="cov8" title="1">usagePercent := 0.0
        if s.capacityBytes &gt; 0 </span><span class="cov8" title="1">{
                usagePercent = float64(totalBytes) / float64(s.capacityBytes) * 100
        }</span>

        <span class="cov8" title="1">avgItemSize := int64(0)
        if totalItems &gt; 0 </span><span class="cov8" title="1">{
                avgItemSize = totalBytes / totalItems
        }</span>

        // 5. Tổng hợp báo cáo
        <span class="cov8" title="1">stats := Stats{
                // Core
                Hits:       hits,
                Misses:     misses,
                Items:      totalItems,
                Bytes:      totalBytes,
                Capacity:   s.capacityBytes,
                Evictions:  atomic.LoadUint64(&amp;s.evictions),
                ShardCount: int(s.shardCount),
                FreqBoost:  atomic.LoadInt64(&amp;s.freqBoost),

                // Performance
                HitRate:      hitRate,
                MissRate:     missRate,
                UsagePercent: usagePercent,
                AvgItemSize:  avgItemSize,

                // Adaptive TTL
                AdaptiveTTL: s.adaptiveTTL != nil,

                // Bloom Filter
                BloomEnabled: s.bloom != nil,
                BloomFPRate:  bloomStats.FalsePositiveRate,
                BloomAvoided: bloomStats.Avoided,

                EvictionStats: evictionStats,

                // Tenant
                TenantID: s.tenantID,
        }

        if s.adaptiveTTL != nil </span><span class="cov0" title="0">{
                stats.AdaptiveMinTTL = s.adaptiveTTL.minTTL.String()
                stats.AdaptiveMaxTTL = s.adaptiveTTL.maxTTL.String()
        }</span>

        <span class="cov8" title="1">return stats</span>
}

func (s *Store) GetEvictionStats() EvictionStatsJSON <span class="cov8" title="1">{
        totalEvictions := s.evictionMetrics.TotalEvictions.Load()
        bytesFreed := s.evictionMetrics.BytesFreed.Load()
        lastEvictionTime := s.lastEvictionTime.Load()

        // Calculate eviction rate (evictions per second)
        evictionRate := 0.0
        if totalEvictions &gt; 0 &amp;&amp; lastEvictionTime &gt; 0 </span><span class="cov8" title="1">{
                // Assume first eviction was at start time (rough estimate)
                duration := time.Now().UnixNano() - lastEvictionTime
                if duration &gt; 0 </span><span class="cov8" title="1">{
                        evictionRate = float64(totalEvictions) / (float64(duration) / 1e9)
                }</span>
        }

        // Average bytes per eviction
        <span class="cov8" title="1">avgBytesPerEviction := int64(0)
        if totalEvictions &gt; 0 </span><span class="cov8" title="1">{
                avgBytesPerEviction = bytesFreed / int64(totalEvictions)
        }</span>

        // Format last eviction timestamp
        <span class="cov8" title="1">lastEvictionAt := ""
        if lastEvictionTime &gt; 0 </span><span class="cov8" title="1">{
                lastEvictionAt = time.Unix(0, lastEvictionTime).Format(time.RFC3339)
        }</span>

        <span class="cov8" title="1">return EvictionStatsJSON{
                TotalEvictions:      totalEvictions,
                AsyncEvictions:      s.evictionMetrics.AsyncEvictions.Load(),
                EmergencyEvictions:  s.evictionMetrics.EmergencyEvictions.Load(),
                BytesFreed:          bytesFreed,
                AvgEvictionTimeMs:   s.evictionMetrics.AvgEvictionTimeMs.Load(),
                LastEvictionMs:      s.evictionMetrics.LastEvictionDuration.Load(),
                LastEvictionAt:      lastEvictionAt,
                InFlight:            s.evictionInFlight.Load(),
                EvictionThreshold:   s.evictionThreshold * 100,
                EvictionTarget:      s.evictionTarget * 100,
                EvictionRate:        evictionRate,
                AvgBytesPerEviction: avgBytesPerEviction,
        }</span>
}

func (s *Store) GetBloomStats() BloomStats <span class="cov8" title="1">{
        hits := atomic.LoadUint64(&amp;s.bloomStats.Hits)
        misses := atomic.LoadUint64(&amp;s.bloomStats.Misses)
        avoided := atomic.LoadUint64(&amp;s.bloomStats.Avoided)

        stats := BloomStats{
                Hits:    hits,
                Misses:  misses,
                Avoided: avoided,
        }

        totalBloomPositives := hits + misses
        if totalBloomPositives &gt; 0 </span><span class="cov0" title="0">{
                stats.FalsePositiveRate = float64(misses) / float64(totalBloomPositives) * 100
        }</span>

        <span class="cov8" title="1">return stats</span>
}

type StatsSnapshot struct {
        Timestamp    int64   `json:"timestamp"`
        Items        int64   `json:"items"`
        Bytes        int64   `json:"bytes"`
        UsagePercent float64 `json:"usage_percent"`
        HitRate      float64 `json:"hit_rate"`
        Evictions    uint64  `json:"evictions"`
}

func (s *Store) GetStatsSnapshot() StatsSnapshot <span class="cov0" title="0">{
        totalBytes := atomic.LoadInt64(&amp;s.totalBytesAtomic)
        hits := atomic.LoadUint64(&amp;s.hits)
        misses := atomic.LoadUint64(&amp;s.misses)

        hitRate := 0.0
        totalRequests := hits + misses
        if totalRequests &gt; 0 </span><span class="cov0" title="0">{
                hitRate = float64(hits) / float64(totalRequests) * 100
        }</span>

        <span class="cov0" title="0">usagePercent := 0.0
        if s.capacityBytes &gt; 0 </span><span class="cov0" title="0">{
                usagePercent = float64(totalBytes) / float64(s.capacityBytes) * 100
        }</span>

        // Quick item count (may be slightly inaccurate)
        <span class="cov0" title="0">itemCount := int64(0)
        for _, sh := range s.shards </span><span class="cov0" title="0">{
                sh.mu.RLock()
                itemCount += int64(len(sh.items))
                sh.mu.RUnlock()
        }</span>

        <span class="cov0" title="0">return StatsSnapshot{
                Timestamp:    time.Now().Unix(),
                Items:        itemCount,
                Bytes:        totalBytes,
                UsagePercent: usagePercent,
                HitRate:      hitRate,
                Evictions:    atomic.LoadUint64(&amp;s.evictions),
        }</span>
}

func (s *Store) ResetStats() <span class="cov0" title="0">{
        atomic.StoreUint64(&amp;s.hits, 0)
        atomic.StoreUint64(&amp;s.misses, 0)
        atomic.StoreUint64(&amp;s.evictions, 0)

        // Reset bloom stats
        atomic.StoreUint64(&amp;s.bloomStats.Hits, 0)
        atomic.StoreUint64(&amp;s.bloomStats.Misses, 0)
        atomic.StoreUint64(&amp;s.bloomStats.Avoided, 0)

        // Reset eviction metrics
        s.evictionMetrics.TotalEvictions.Store(0)
        s.evictionMetrics.AsyncEvictions.Store(0)
        s.evictionMetrics.EmergencyEvictions.Store(0)
        s.evictionMetrics.BytesFreed.Store(0)
        s.evictionMetrics.AvgEvictionTimeMs.Store(0)
        s.evictionMetrics.LastEvictionDuration.Store(0)
}</span>

type HealthStatus struct {
        Healthy        bool    `json:"healthy"`
        Status         string  `json:"status"`
        UsagePercent   float64 `json:"usage_percent"`
        EvictionActive bool    `json:"eviction_active"`
        Message        string  `json:"message,omitempty"`
}

func (s *Store) HealthCheck() HealthStatus <span class="cov0" title="0">{
        usage := 0.0
        if s.capacityBytes &gt; 0 </span><span class="cov0" title="0">{
                usage = float64(atomic.LoadInt64(&amp;s.totalBytesAtomic)) / float64(s.capacityBytes) * 100
        }</span>

        <span class="cov0" title="0">evictionActive := s.evictionInFlight.Load()

        // Determine health status
        status := "healthy"
        healthy := true
        message := ""

        if usage &gt;= 95 </span><span class="cov0" title="0">{
                status = "critical"
                healthy = false
                message = "Cache usage critical (&gt;95%)"
        }</span> else<span class="cov0" title="0"> if usage &gt;= 85 </span><span class="cov0" title="0">{
                status = "warning"
                message = "Cache usage high (&gt;85%)"
        }</span>

        <span class="cov0" title="0">if evictionActive </span><span class="cov0" title="0">{
                message += " | Eviction in progress"
        }</span>

        <span class="cov0" title="0">return HealthStatus{
                Healthy:        healthy,
                Status:         status,
                UsagePercent:   usage,
                EvictionActive: evictionActive,
                Message:        message,
        }</span>
}

type ShardStats struct {
        Index int   `json:"index"`
        Items int   `json:"items"`
        Bytes int64 `json:"bytes"`
}

func (s *Store) GetShardDistribution() []ShardStats <span class="cov0" title="0">{
        shardStats := make([]ShardStats, len(s.shards))

        for i, sh := range s.shards </span><span class="cov0" title="0">{
                sh.mu.RLock()
                shardStats[i] = ShardStats{
                        Index: i,
                        Items: len(sh.items),
                        Bytes: sh.bytes,
                }
                sh.mu.RUnlock()
        }</span>

        <span class="cov0" title="0">return shardStats</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package engine

import (
        "container/list"
        "context"
        "sync/atomic"
        "time"

        "github.com/AutoCookies/pomai-cache/shared/ds/bloom"
)

// TTLRemaining kiểm tra thời gian sống còn lại của một key.
// Trả về: (thời gian còn lại, key có tồn tại hay không).
// Nếu key đã hết hạn, nó sẽ kích hoạt Lazy Delete và trả về (0, false).
func (s *Store) TTLRemaining(key string) (time.Duration, bool) <span class="cov8" title="1">{
        if key == "" </span><span class="cov0" title="0">{
                return 0, false
        }</span>

        // 1. Fast fail với Bloom Filter
        <span class="cov8" title="1">if s.bloom != nil &amp;&amp; !s.bloom.MayContain(key) </span><span class="cov0" title="0">{
                return 0, false
        }</span>

        <span class="cov8" title="1">sh := s.getShard(key)

        // 2. Kiểm tra nhanh bằng Read Lock
        sh.mu.RLock()
        elem, ok := sh.items[key]
        if !ok </span><span class="cov0" title="0">{
                sh.mu.RUnlock()
                return 0, false
        }</span>

        <span class="cov8" title="1">ent := elem.Value.(*entry)

        // Nếu không có TTL (vĩnh viễn)
        if ent.expireAt == 0 </span><span class="cov0" title="0">{
                sh.mu.RUnlock()
                return 0, true
        }</span>

        <span class="cov8" title="1">remain := time.Until(time.Unix(0, ent.expireAt))
        sh.mu.RUnlock() // Giải phóng Read Lock ngay

        // 3. Nếu đã hết hạn -&gt; Lazy Delete (Cần Write Lock)
        if remain &lt;= 0 </span><span class="cov0" title="0">{
                s.deleteExpired(key)
                return 0, false
        }</span>

        <span class="cov8" title="1">return remain, true</span>
}

// deleteExpired là hàm helper xóa key nếu nó thực sự đã hết hạn.
// Hàm này tự quản lý Lock, an toàn để gọi từ các luồng khác.
func (s *Store) deleteExpired(key string) <span class="cov8" title="1">{
        sh := s.getShard(key)
        sh.mu.Lock()
        defer sh.mu.Unlock()

        // Double-check: Kiểm tra lại xem key còn đó và còn hết hạn không
        // (tránh trường hợp luồng khác đã update key này giữa lúc ta chuyển lock)
        if elem, ok := sh.items[key]; ok </span><span class="cov8" title="1">{
                ent := elem.Value.(*entry)
                if ent.expireAt != 0 &amp;&amp; time.Now().UnixNano() &gt; ent.expireAt </span><span class="cov8" title="1">{
                        // Xóa khỏi Map và List
                        delete(sh.items, key)
                        sh.ll.Remove(elem)

                        // Cập nhật bộ nhớ
                        sh.bytes -= int64(ent.size)
                        atomic.AddInt64(&amp;s.totalBytesAtomic, -int64(ent.size))

                        // Giải phóng Global Memory nếu có
                        if GlobalMemCtrl != nil </span><span class="cov0" title="0">{
                                GlobalMemCtrl.Release(int64(ent.size))
                        }</span>
                }
        }
}

// StartCleanup bắt đầu một Goroutine chạy ngầm để dọn dẹp định kỳ.
func (s *Store) StartCleanup(ctx context.Context, interval time.Duration) <span class="cov0" title="0">{
        ticker := time.NewTicker(interval)
        go func() </span><span class="cov0" title="0">{
                defer ticker.Stop()
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                s.CleanupExpired()</span>
                        }
                }
        }()
}

// CleanupExpired quét toàn bộ cache và xóa các key hết hạn (Active Expiration).
// Trả về số lượng key đã xóa.
func (s *Store) CleanupExpired() int <span class="cov0" title="0">{
        now := time.Now().UnixNano()
        cleaned := 0

        // Duyệt qua từng shard để dọn dẹp
        // Chúng ta lock từng shard một để không chặn toàn bộ hệ thống
        for _, sh := range s.shards </span><span class="cov0" title="0">{
                sh.mu.Lock()

                // 1. Tìm các key hết hạn trong shard này
                // (Lưu vào slice tạm để tránh lỗi khi vừa duyệt vừa xóa map)
                toDelete := make([]*list.Element, 0)

                for _, elem := range sh.items </span><span class="cov0" title="0">{
                        ent := elem.Value.(*entry)
                        if ent.expireAt != 0 &amp;&amp; now &gt; ent.expireAt </span><span class="cov0" title="0">{
                                toDelete = append(toDelete, elem)
                        }</span>
                }

                // 2. Xóa chúng
                <span class="cov0" title="0">for _, elem := range toDelete </span><span class="cov0" title="0">{
                        ent := elem.Value.(*entry)
                        if _, exists := sh.items[ent.key]; exists </span><span class="cov0" title="0">{
                                delete(sh.items, ent.key)
                                sh.ll.Remove(elem)

                                sh.bytes -= int64(ent.size)
                                atomic.AddInt64(&amp;s.totalBytesAtomic, -int64(ent.size))
                                if GlobalMemCtrl != nil </span><span class="cov0" title="0">{
                                        GlobalMemCtrl.Release(int64(ent.size))
                                }</span>
                                <span class="cov0" title="0">cleaned++</span>
                        }
                }

                <span class="cov0" title="0">sh.mu.Unlock()</span>
        }

        // 3. Tái tạo Bloom Filter nếu xóa quá nhiều
        // Bloom Filter không hỗ trợ xóa, nên nếu xóa nhiều key, nó sẽ bị "bẩn" (tỷ lệ dương tính giả cao).
        // Ta cần xây lại nó để đảm bảo hiệu suất.
        <span class="cov0" title="0">if cleaned &gt; 1000 &amp;&amp; s.bloom != nil </span><span class="cov0" title="0">{
                go s.RebuildBloomFilter()
        }</span>

        <span class="cov0" title="0">return cleaned</span>
}

// RebuildBloomFilter xây dựng lại Bloom Filter từ dữ liệu hiện có.
// Chạy trong background để tránh block.
func (s *Store) RebuildBloomFilter() <span class="cov0" title="0">{
        // Giả định dung lượng Bloom Filter dựa trên số item hiện tại + 10% buffer
        // (Hoặc giữ nguyên cấu hình cũ nếu lưu lại config size/k)

        // Để đơn giản, ta tạo mới bloom filter với kích thước mặc định hoặc config đã lưu
        // Ở đây ta cần access vào struct Bloom cũ để lấy config size/k,
        // nhưng struct bloom.BloomFilter trong pkg/ds ẩn field size/k.
        // -&gt; Cách tốt nhất: Tạo mới dựa trên estimation items hiện tại.

        totalItems := int64(0)
        for _, sh := range s.shards </span><span class="cov0" title="0">{
                sh.mu.RLock()
                totalItems += int64(len(sh.items))
                sh.mu.RUnlock()
        }</span>

        <span class="cov0" title="0">if totalItems == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // Ước tính: size = n * 10 (cho sai số ~1%), k = 7
        <span class="cov0" title="0">newSize := uint64(totalItems * 10)
        if newSize &lt; 1024 </span><span class="cov0" title="0">{
                newSize = 1024
        }</span>
        <span class="cov0" title="0">newBloom := bloom.New(newSize, 7)

        // Populate dữ liệu vào bloom mới
        for _, sh := range s.shards </span><span class="cov0" title="0">{
                sh.mu.RLock()
                for key := range sh.items </span><span class="cov0" title="0">{
                        newBloom.Add(key)
                }</span>
                <span class="cov0" title="0">sh.mu.RUnlock()</span>
        }

        // Swap con trỏ (Atomic swap an toàn hơn, nhưng gán trực tiếp cũng ổn vì pointer assignment là atomic trên x64)
        <span class="cov0" title="0">s.bloom = newBloom</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package engine

import (
        "github.com/AutoCookies/pomai-cache/shared/ds/skiplist"
)

func (s *Store) ZAdd(key, member string, score float64) <span class="cov8" title="1">{
        if key == "" || member == "" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">s.zmu.Lock()
        defer s.zmu.Unlock()

        // Defensive check
        if s.zsets == nil </span><span class="cov0" title="0">{
                s.zsets = make(map[string]*skiplist.Skiplist)
        }</span>

        <span class="cov8" title="1">ss, ok := s.zsets[key]
        if !ok </span><span class="cov8" title="1">{
                ss = skiplist.New()
                s.zsets[key] = ss
        }</span>
        <span class="cov8" title="1">ss.Add(member, score)</span>
}

func (s *Store) ZRange(key string, start, stop int) []string <span class="cov8" title="1">{
        if key == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">s.zmu.RLock()
        ss := s.zsets[key]
        s.zmu.RUnlock()

        if ss == nil </span><span class="cov0" title="0">{
                return []string{}
        }</span>
        <span class="cov8" title="1">return ss.Range(start, stop)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package engine

import (
        "sync"
        "time"
)

// TenantManager manages per-tenant stores.
type TenantManager struct {
        mu                sync.RWMutex
        stores            map[string]*Store
        slots             map[string]chan struct{} // semaphore per tenant
        shardCount        int
        perTenantCapacity int64
        maxConcurrent     int // maximum concurrent requests per tenant
}

// NewTenantManager creates a manager that will create per-tenant stores on demand.
// shardCount is forwarded to each per-tenant store. perTenantCapacity is bytes quota per tenant (0 = unlimited).
// This constructor keeps the old signature and uses a sensible default for max concurrent per tenant.
func NewTenantManager(shardCount int, perTenantCapacity int64) *TenantManager <span class="cov0" title="0">{
        // default max concurrent per tenant
        return NewTenantManagerWithLimit(shardCount, perTenantCapacity, 100)
}</span>

// NewTenantManagerWithLimit allows specifying maximum concurrent requests per tenant.
func NewTenantManagerWithLimit(shardCount int, perTenantCapacity int64, maxConcurrentPerTenant int) *TenantManager <span class="cov0" title="0">{
        if maxConcurrentPerTenant &lt;= 0 </span><span class="cov0" title="0">{
                maxConcurrentPerTenant = 100
        }</span>
        <span class="cov0" title="0">return &amp;TenantManager{
                stores:            make(map[string]*Store),
                slots:             make(map[string]chan struct{}),
                shardCount:        shardCount,
                perTenantCapacity: perTenantCapacity,
                maxConcurrent:     maxConcurrentPerTenant,
        }</span>
}

// GetStore returns the Store for the given tenantID, creating it if needed.
func (tm *TenantManager) GetStore(tenantID string) *Store <span class="cov0" title="0">{
        // fast path read lock
        tm.mu.RLock()
        s, ok := tm.stores[tenantID]
        tm.mu.RUnlock()
        if ok </span><span class="cov0" title="0">{
                return s
        }</span>

        // create under write lock
        <span class="cov0" title="0">tm.mu.Lock()
        defer tm.mu.Unlock()
        // double-check
        if s, ok = tm.stores[tenantID]; ok </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">s = NewStoreWithOptions(tm.shardCount, tm.perTenantCapacity)
        tm.stores[tenantID] = s

        // Create semaphore (channel) for tenant concurrency control
        if _, ok := tm.slots[tenantID]; !ok </span><span class="cov0" title="0">{
                tm.slots[tenantID] = make(chan struct{}, tm.maxConcurrent)
        }</span>

        <span class="cov0" title="0">return s</span>
}

// AcquireTenant attempts to acquire a slot for tenantID. If timeout &lt;= 0 it blocks until acquired.
func (tm *TenantManager) AcquireTenant(tenantID string, timeout time.Duration) bool <span class="cov0" title="0">{
        // Ensure slot exists
        tm.mu.Lock()
        ch, ok := tm.slots[tenantID]
        if !ok </span><span class="cov0" title="0">{
                ch = make(chan struct{}, tm.maxConcurrent)
                tm.slots[tenantID] = ch
        }</span>
        <span class="cov0" title="0">tm.mu.Unlock()

        // Try to acquire
        if timeout &lt;= 0 </span><span class="cov0" title="0">{
                // blocking acquire
                ch &lt;- struct{}{}
                return true
        }</span>

        <span class="cov0" title="0">select </span>{
        case ch &lt;- struct{}{}:<span class="cov0" title="0">
                return true</span>
        case &lt;-time.After(timeout):<span class="cov0" title="0">
                return false</span>
        }
}

// ReleaseTenant releases a previously acquired slot. It is safe to call even if the tenant slot map entry was removed.
func (tm *TenantManager) ReleaseTenant(tenantID string) <span class="cov0" title="0">{
        tm.mu.RLock()
        ch, ok := tm.slots[tenantID]
        tm.mu.RUnlock()
        if !ok </span><span class="cov0" title="0">{
                // Nothing to release (shouldn't happen in normal flow)
                return
        }</span>
        <span class="cov0" title="0">select </span>{
        case &lt;-ch:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0"></span>
                // nothing to release (avoid blocking)
        }
}

// StatsForTenant returns Stats for a specific tenant store; returns false if tenant not found.
func (tm *TenantManager) StatsForTenant(tenantID string) (Stats, bool) <span class="cov0" title="0">{
        tm.mu.RLock()
        s, ok := tm.stores[tenantID]
        tm.mu.RUnlock()
        if !ok </span><span class="cov0" title="0">{
                return Stats{}, false
        }</span>
        <span class="cov0" title="0">return s.Stats(), true</span>
}

// ListTenants returns a slice of tenant IDs currently known.
func (tm *TenantManager) ListTenants() []string <span class="cov0" title="0">{
        tm.mu.RLock()
        defer tm.mu.RUnlock()
        out := make([]string, 0, len(tm.stores))
        for id := range tm.stores </span><span class="cov0" title="0">{
                out = append(out, id)
        }</span>
        <span class="cov0" title="0">return out</span>
}

// StatsAll returns a map tenantID -&gt; Stats snapshot for all known tenants.
func (tm *TenantManager) StatsAll() map[string]Stats <span class="cov0" title="0">{
        tm.mu.RLock()
        defer tm.mu.RUnlock()
        out := make(map[string]Stats, len(tm.stores))
        for id, s := range tm.stores </span><span class="cov0" title="0">{
                out[id] = s.Stats()
        }</span>
        <span class="cov0" title="0">return out</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
